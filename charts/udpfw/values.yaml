# nameOverride -- Override name of app
nameOverride:  # ""

# fullnameOverride -- Override the full qualified app name
fullnameOverride:  # ""

## global -- Globally shared configuration
global:
  # global.additionalLabels -- Common labels for the all resources
  additionalLabels: {}
  # app: udpfw

  # global.image -- Define the image to work with
  image:
    # global.image.repository -- Repository to use
    repository: ghcr.io/udpfw/udpfw

    # global.image.tag -- Overrides the global Helm image tag whose default is the chart appVersion
    tag: ""

    # global.image.pullPolicy -- Image pullPolicy
    pullPolicy: IfNotPresent

## dispatch -- Dispatch container configuration
dispatch:

  # dispatch.defaultPort -- Default port to listen TCP packets
  defaultPort: 2727

  # dispatch.bindIPV6 -- If the server must bind IPV6 or IPV4 (defaults to IPV4)
  bindIPV6: false

  # dispatch.enableDebugLog -- Enable log in debug level
  enableDebugLog: false

  # dispatch.securityContext -- Allows you to overwrite the default PodSecurityContext on the dispatch container
  securityContext:
    capabilities:
      add:
        - NET_ADMIN
    privileged: true

  # dispatch.ports -- Allows to specify extra ports (hostPorts for instance) for this container
  ports: []

  # dispatch.resources -- Resource requests and limits for the this container.
  resources: {}
  #  requests:
  #    cpu: 200m
  #    memory: 256Mi
  #  limits:
  #    cpu: 200m
  #    memory: 256Mi

  # dispatch.livenessProbe -- Add liveness probe settings
  # @default -- Every 15s / 6 KO / 1 OK
  livenessProbe: {}

  # dispatch.readinessProbe -- Add readiness probe settings
  readinessProbe: {}

  # dispatch.env -- Additional environment variables for this container
  env: []

  # dispatch.envFrom -- Set environment variables specific to container from configMaps and/or secrets
  envFrom: []
  #   - configMapRef:
  #       name: <CONFIGMAP_NAME>
  #   - secretRef:
  #       name: <SECRET_NAME>

  # dispatch.envDict -- Set environment variables specific to this container defined in a dict
  envDict: {}
  #   <ENV_VAR_NAME>: <ENV_VAR_VALUE>

  # dispatch.nats -- NATS PubSub Server configuration
  nats:
    # dispatch.nats.url -- URL for a NATS server (when using NATS for pubsub)
    url: ""
    # dispatch.nats.subscriptionSubject -- Name of a NATS subscription subject where data will be exchanged
    subscriptionSubject: "dispatch-dispatch-exchange"
    # dispatch.nats.userCredentials -- NATS user's JWT path
    userCredentials: ""
    # dispatch.nats.userCredentialsNkey -- NATS user's private Nkey seed path
    userCredentialsNkey: ""
    # dispatch.nats.nkeyFromSeed -- NATS user's bare nkey seed path
    nkeyFromSeed: ""
    # dispatch.nats.rootCA -- Path to Root CA for a self-signed TLS certificate
    rootCA: ""
    # dispatch.nats.clientCertificate -- NATS client certificate path
    clientCertificate: ""
    # dispatch.nats.clientKey -- NATS client certificate key path
    clientKey: ""

  # dispatch.redis -- Redis PubSub Server configuration
  redis:
    # dispatch.redis.url -- Redis URL (when using Redis for pubsub)
    url: ""
    # dispatch.redis.channel -- Redis channel name where data will be exchanged
    channel: "udpfw-dispatch-exchange"

# daemonset -- Daemonset configuration
daemonset:
  # daemonset.annotations -- Adds annotations to the daemonset
  annotations: {}
  # daemonset.labels -- Adds labels to the daemonset
  labels: {}
  # daemonset.revisionHistoryLimit -- The number of ControllerRevision to keep in this DaemonSet.
  revisionHistoryLimit: 1

  # daemonset.updateStrategy -- Allow the DaemonSet to perform a rolling update on helm update

  ## ref: https://kubernetes.io/docs/tasks/manage-daemon/update-daemon-set/
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: "10%"

  pod:
    # daemonset.pod.annotations -- Adds annotations to the daemonset pod
    annotations: {}
    # daemonset.pod.labels -- Adds labels to the daemonset pod
    labels: {}

    # daemonset.pod.useHostNetwork -- Bind ports on the hostNetwork

    ## Useful for CNI networking where hostPort might
    ## not be supported. The ports need to be available on all hosts. It Can be
    ## used for custom metrics instead of a service endpoint.
    ##
    ## WARNING: Make sure that hosts using this are properly firewalled otherwise
    ## metrics and traces are accepted from any host able to connect to this host.
    useHostNetwork: false

    # daemonset.pod.dnsPolicy -- Pod's DNS policy

    ## See https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy
    dnsPolicy: "ClusterFirst"

    # daemonset.pod.imagePullSecrets -- Repository pullSecret (ex: specify docker registry credentials)

    ## See https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
    imagePullSecrets: []
    #   - name: "<REG_SECRET>"

    # daemonset.pod.priorityClassCreate -- Creates a priorityClass for the Daemonset pods.
    priorityClassCreate: true

    # daemonset.pod.priorityClassName -- Sets PriorityClassName if defined
    priorityClassName:

    # daemonset.pod.priorityPreemptionPolicyValue -- Set to "Never" to change the PriorityClass to non-preempting
    priorityPreemptionPolicyValue: PreemptLowerPriority

    # daemonset.pod.priorityClassValue -- Value used to specify the priority of the scheduling of Daemonset pods.

    ## The PriorityClass uses PreemptLowerPriority.
    priorityClassValue: 1000000000

    # daemonset.pod.tolerations -- Allow the DaemonSet to schedule on tainted nodes (requires Kubernetes >= 1.6)
    tolerations:
      - operator: Exists

    # daemonset.pod.nodeSelector -- Allow the DaemonSet to schedule on selected nodes

    ## Ref: https://kubernetes.io/docs/user-guide/node-selection/
    nodeSelector: {}

    # daemonset.pod.affinity -- Allow the DaemonSet to schedule using affinity rules

    ## Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
    affinity: {}

# serviceAccount -- Service Account configuration
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # Labels to add to the service account
  labels: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

## redis -- When `redis.enabled=true` deploys a redis master/replica using Redis Bitnami's subchart
# Ref: https://github.com/bitnami/charts/blob/main/bitnami/redis/values.yaml
redis:
  # -- Enables the Redis subchart
  enabled: false
  cluster:
    init: false
    auth:
      enabled: false
    persistence:
      enabled: false
    master:
      extraFlags:
        - --maxmemory-policy volatile-ttl
        - --repl-backlog-size 384mb
        - --loglevel warning
      resources:
        requests:
          memory: 256m
          cpu: 100m
    sysctl:
      enabled: true
      mountHostSys: true
      resources:
        requests:
          memory: 64Mi
          cpu: 10m
      command:
        - /bin/sh
        - -c
        - |-
          install_packages procps
          sysctl -w net.core.somaxconn=10000
          echo never > /host-sys/kernel/mm/transparent_hugepage/enabled

## nats -- When `nats.enabled=true` deploys a nats cluster using Nats's subchart
# Ref: https://github.com/nats-io/k8s/blob/main/helm/charts/nats/values.yaml
nats:
  # -- Enables the Nats subchart
  enabled: true
  config:
    cluster:
      enabled: true
